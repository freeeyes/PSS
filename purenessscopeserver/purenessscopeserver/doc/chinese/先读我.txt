
一。为什么要设计PurenessScopeServer？
在我的到目前为止开发生涯中，其实一直挺讨厌网络通讯模块的，为什么？首先还是自己做的并不是很精，而我也是一个懒人，不喜欢成天纠结着IOCP,EPOLL,SELECT之类的模式词汇。
纵观这几年自己做过的一些项目，几乎每个项目都离不开网络，自己经历开发的几款网络游戏，所用的模型都不同，而且写多了自己也快乱掉了，而且不具备通用性和移植性。
几年前，忽然想，是否可以设计出一款跨平台，与逻辑无关的网络框架？我可不想每次都一遍遍的重写网络模块。而且要做到和逻辑无关。其实这个想法从我工作的第二年就开始有了。
自己也尝试的写了几个模块程序，那时候封装了一个IOCP的代码，不过这些代码只能运行在windows上，达不到我的要求。
后来工作需要，接触了ACE，我用了一年半的时间，来熟悉ACE的各种特性，这一段时间的摸索，花费了不少时间，由于需要大量的精力去开发调试逻辑，走了不少弯路。
于是在那个项目中，我开始尝试自己的梦想，既然有跨平台的库，我为什么不能把它进化成一个消息的传输和分发的框架呢。
不过项目启动初期并不顺利，由于是linux下第一次使用ace，在加上项目比较紧，走了不少弯路。最初的版本并没有达到我的预期。
于是在两年前，决定沉下心来，重做一个真正具备商业使用价值的一个框架，它的目标是解决我的数据传输和消息分发。让我不再关心这部分，而是全部精力放在逻辑开发上。
于是我定义了一个框架的目标。
1.实现逻辑和数据传输的分离，所有的逻辑全部通过模块的方式加载（dll或者是so）。
2.逻辑模块可以通过管理工具轻松的插拔，类似于USB硬盘，这样做的好处是，我可以方便的调试我的模块功能，并可以提供服务器不停机升级指定模块的服务。
3.支持TCP和UDP协议，并且，允许程序员自己去定义协议的格式，可以是压缩，加密，二进制协议，文本协议。框架不应该制约数据的格式
4.支持多线程的数据分发模式，在对于每个模块的某个协议而言，它可以清楚的知道这个数据包是来源于谁。
5.为每个模块提供收发模块，模块可以轻松使用这些资源，并且不用去维护这些资源。对于调用者是透明的。
6.必须有足够的数据监控能力，一个链接收发了多少数据，服务器有多少链接，每个协议的实际处理时间，工作线程的状态和数据吞吐量，这些都必须提供给开发者，用于对自己模块服务的监控。
7.强大的日志系统，可以记录框架在服务中产生的异常和正常的数据。
8.支持数据的转发服务，开发者可以轻松的把数据转发给另外的服务器。

这样，对于我而言，我不在关心这些数据底层的问题，而将精力放在不同的逻辑数据处理上。并可以提供不停机的模块卸载和加载。从而减少服务重启进程。
当然，要做到上述的这一切，付出是必不可少的。从最初的0.50版本，到现在的版本，弯路也真的走了不少，光ConnectHander的代码就至少重写了3遍。当然，一切都是为了让它变的更好。
PurenessScopeServer的名字由来，也是由Pureness（纯粹）+ Scope（范围），希望它越来越有价值，能够真正的帮助开发者起到实际的作用。
在这里，我期待有兴趣的朋友更多的参与到它的开发中来，并提供出你的宝贵建议，让它更方便的给更多的开发同仁们创造实际的便利，这就是它的价值所在。
感谢winston，KimilesWood，jackypeng，jamesyang680，7cat，modern，badbrain，Dave，五彩修改花针等朋友的大力支持（排名不分先后），正是有你们的存在，它才会一步步的成长，谢谢你们。
说实话，我并不期待它未来会成为什么，而是希望它真正能给你我，这些开发者，多一分的自信和便利。并能用它展现出你的精彩，越短的时间实现你的想法是它的目标，而不是花精力研究它本身。
越简单就越不容易出错，我一直坚信的信条，尤其是简单到能让初学者都顺利看懂上手的代码是我追求的目标，这才是价值的体现。所以，在框架设计中，我尽量用简单的代码解决问题。方便与阅读者，也方便与自己。
最新的代码可以在www.acejoy.com上得到。

二。为什么要用PurenessScopeServer，它能给我提供什么？我需要为此付出什么？它适用于什么领域范围？
PurenessScopeServer实际就是一个数据分发平台。支持自定义的格式的数据包（这部分由开发者自己决定，具体使用请参考《PacketPrase说明书》）
开发者可以通过配置文件来控制服务器功能（这部分请参考《配置文件说明书》），而不用在开发额外的代码。
其实我的终极目标是，开发者可以不用阅读框架的代码（有兴趣的除外），你只要懂得如何编译它，学会配置它，让它为你服务，就可以了。你可以专注于你的逻辑实现。
它可以负责传输数据，相应的，在逻辑模块，你需要遵循一定的格式和方法，去获得这些数据，并订阅那些你感兴趣的消息。
框架支持多重订阅，就是一个消息，你可以根据消息的ID，分别在不同的模块定义接受者。
（举个例子，比如我可以在模块1中订阅1号消息，记录消息到来的时间日志，在模块2中订阅1号消息，处理消息的本体，这样代码看上去非常清晰。框架会发给这两个模块，互不干扰）
那么，开发者可以不可以脱离框架写自己的逻辑呢？也就是说，我可否在没有框架的时候，编写那些模块文件？比如dll和so？答案当然是可以的。具体方法请参考我的example-Module文件夹下的例子。
目前的例子包括基础的数据收发方法，UDP和TCP的，还有一个用户登录引擎，包括数据多级缓冲机制（这部分请关注acejoy上我写的多级缓冲机制的文章）。以后我会不断的持续添加样例模块，帮助大家分享一些开发方法。
PurenessScopeServer由4部分组成，其中两部分来协助完成。他们分别是：
1.框架程序本身（不需要开发者去编写任何代码，当然，配置文件需要开发者去做一些配置）
2.PacketParse部分（需要开发者编写，用于定义数据协议的格式，目前是包头和包体，还有一个标明协议的标记号）
3.功能模块（需要开发者编写，完成你的逻辑）
4.客户端框架管理工具（这部分不需要开发者去编写，开发者可以用这个工具监控框架服务的各种状态）
目前，PurenessScopeServer适合于TCP和UDP协议的开发。你可以通过配置框架支持以上协议。

三。用PurenessScopeServer需要注意什么？
需要注意的是在windows和linux下，由于环境的不同，需要一些基础的网络知识配置。
比如在linux和windows下，进程IO数的配置，在linux下注意，如果配置不对可能会导致一些链接建立不正常。（linux下 ulimit -a查看）
具体请参考doc文件夹下的说明文件。

本程序需要依赖ACE才能运行，请到http://www.cs.wustl.edu/~schmidt/ACE.html下载ACE的运行库。
编译教程请参考http://www.cs.wustl.edu/~schmidt/ACE-install.html
在编译完ACE后，请在对应权限的.bash_profile文件中添加

这里要注意，如果你要使用IPv6，必须在ace的config.h里面添加
#define ACE_HAS_IPV6

如果想用configure去编译。
记得先yum -y install openssl-devel (RedHat Linux) 
否则会提示找不到ssl的库
或者 ../configure --disable-ssl
如果你用不到SSL的话
或者，如果你想手动编译

配置环境变量：
# vi /etc/profile
增加如下的内容
ACE_ROOT=/Software/ACE_wrappers      ------就是上面存放ACE源文件的目录
export ACE_ROOT

LD_LIBARY_PATH=$ACE_ROOT/ace:$LD_LIBRARY_PATH
export LD_LIBRARY_PATH
# source /etc/profile

你可以先在ace目录下创建一个config.h
添加如下代码
#include "ace/config-linux.h"
然后进入$ACE_ROOT/include/makeinclude
新建 platform_macros.GNU，在中加入一行如 下：
include $(ACE_ROOT)/include/makeinclude/platform_linux.GNU

然后回到ace目录
make
编译完成后，检查上一层lib文件夹下的libace.so是否存在，存在则编译成功。

LD_LIBRARY_PATH=/usr/local/lib/:/home/freeeyes/PurenessScopeServer/PurenessScopeServer/Linux_Bin/
export LD_LIBRARY_PATH

ACE_ROOT=/usr/src/ACE_wrappers
export ACE_ROOT

解释一下，/home/freeeyes/PurenessScopeServer/PurenessScopeServer/Linux_Bin/是你的工程工作路径，/usr/local/lib/是你的libace.lib的路径
ACE_ROOT是你的ACE安装路径。

如果要运行./runlinuxmpc.sh 生成编译配置文件，请先确认安装了perl。
并请在环境变量里面添加
PATH=$PATH:/root/tools/ACE_wrappers/bin
export PATH你把这个加到你的文档中吧

另外，如果在linux下使用epoll模型的话
请配置/etc/security/limits.conf文件。

在里面添加
*        soft    noproc  10000
*        hard    noproc  10000
*        soft    nofile  10000
*        hard    nofile  10000

如果你要用默认的并行端口打开数，比如1024，那么请修改define.h里面的MAX_DEV_POLL_COUNT 为 1000


得到代码后，请先编译PacketParse目录下的文件。成功生成libPacketParse.so后，拷贝到PurenessScopeServer下的Linux_bin目录下，
然后在Linux_bin下运行make命令。

首先编译PurenessScopeServer工程，然后编译PacketPrase工程，把生成的so或者dll拷贝到PurenessScopeServer工程下的相应目录下(Windows是Windows_bin，Linux是Linux_Bin)
然后编译example-Module里面的你想测试的模块。把生成的so或者dll放在PurenessScopeServer工程下的相应目录下(Windows是Windows_bin，Linux是Linux_Bin)，
并修改main.conf文件中的ModuleString，你也可以把你的所有逻辑so放在一个你指定的目录下并设置ModulePath。（具体请参考，配置文件说明书）

附注：
目前Pss支持加载为windows服务，如果要想Pss以windows服务启动
首先确保自己在管理员权限下。
然后打开main.xml
修改<ServerType Type="1" name="Pss Service" displayname="PssService">
这里Type=1为程序以windows服务的形式启动
启动方法，需要在命令行模式下(cmd)，到当前目录，然后运行框架 PurenessScopeServer_D.exe -i
注册windows服务。
然后在windows服务管理器下（或者在命令行下，使用PurenessScopeServer_D.exe -s）启动和停止服务。
如果要删除服务，则需要在命令行下PurenessScopeServer_D.exe -r
注意，如果要以服务形式启动，必须框架依赖的dll都在当前路径下，或者在环境变量path指定的路径下。否则会启动失败。